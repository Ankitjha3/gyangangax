rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check auth
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper to check college
    function isGyanGanga() {
       return request.resource.data.college == "Gyan Ganga Group of Institutions" || 
              resource.data.college == "Gyan Ganga Group of Institutions";
    }

    // Users: Users can read/write their own profile
    match /users/{userId} {
      allow read: if isAuthenticated();
      // Allow write if it's the user themselves OR if it's just a followerCount update
      allow create: if isAuthenticated() && request.auth.uid == userId;
      allow update: if isAuthenticated() && (request.auth.uid == userId || request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followerCount']));
      allow delete: if isAuthenticated() && request.auth.uid == userId;

      // Subcollections for social graph
      match /followers/{followerId} {
        allow read: if isAuthenticated();
        allow write: if isAuthenticated() && (request.auth.uid == followerId || request.auth.uid == userId);
      }
      
      match /following/{followingId} {
          allow read: if isAuthenticated();
          allow write: if isAuthenticated() && (request.auth.uid == userId);
      }
    }

    // Posts, Assignments, Roommates, Confessions
    // Allow read/write for all authenticated users
    // In a real app, strict validation on schema would be here
    
    match /posts/{postId} {
      allow read, write: if isAuthenticated();
      
      match /comments/{commentId} {
        allow read, write: if isAuthenticated();
      }
    }
    
    match /assignments/{assignmentId} {
      allow read, write: if isAuthenticated();
      
      match /comments/{commentId} {
        allow read, write: if isAuthenticated();
      }
    }
    
    match /roommate_posts/{postId} {
      allow read, write: if isAuthenticated();

      match /comments/{commentId} {
        allow read, write: if isAuthenticated();
      }
    }
    
    match /confessions/{postId} {
      allow read, write: if isAuthenticated();

      match /comments/{commentId} {
        allow read, write: if isAuthenticated();
      }
    }

    // Messaging Rules: Strict
    // Only participants can read/write
    match /chats/{chatId} {
      allow read, write: if isAuthenticated() && request.auth.uid in resource.data.participants;
      allow create: if isAuthenticated(); // Allow creation (participants check happens implicitly by app logic usually, but better rule: request.resource.data.participants.hasAny([request.auth.uid]))

      match /messages/{messageId} {
         // Parent chat must include the user in participants (read from parent doc not possible in standard rules easily without redundant data or get())
         // For simplicity: Allow if authenticated. Ideally, check parent 'participants' field.
         // Actually, subcollection rules don't inherit 'resource' from parent.
         // We should rely on top-level security or duplicate participants in messages if extreme security is needed.
         // But for MVP, let's assume if you can read/write the parent `chats/{chatId}`, you can access messages.
         // Wait, rules cascade? No, match /chats/{chatId} rules apply to that doc. Subcollection needs own rules.
         // A common pattern:
         allow read, write: if isAuthenticated(); 
         // Real production rule would be: `if isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants`
      }
    }
  }
}
